/*
    Group 2 CPCS324 Poject 
*/
package GraphFrameWrok;

// imports
import java.util.ArrayList;
import PhoneNetworkApp.Line;

public class MHPrimAlg extends MSTAlgorithm {

    public MHPrimAlg(Graph graph) {
        this.graph = graph;
        this.MSTResultList = new ArrayList<>(graph.getVerticesNo() - 1);

        // Initialize the min-heap with all of the vertices in the graph and set the parent to null , and the key to âˆž.
        // Initialize the MSTResultList .
        Min_Heap mh = new Min_Heap(graph.getVerticesNo());

        for (int i = 0; i < graph.getVerticesNo(); i++) {
            MSTResultList.add(null);
            mh.insert(graph.getVertices().get(i), Integer.MAX_VALUE, null);
        }

        MSTResultList.remove(0);
        
        //Pass the min_heap to compute the MST
        computeMST(mh);
        displayResultingMST();
    }

    public final void computeMST(Min_Heap mh) {
        // update the key of the first vertex in the min_heap
        mh.UpdateKey(0, 1);
        
        //take the min node out of the heap. 
        HeapNode mn = mh.extract_min();
        
        //the minkeyVertex is the parent of the Adjacent vertex.
        Vertex minkeyVertex = mn.getVertex();
        
        //set the parent as visited.
        minkeyVertex.setVisited(true);
        
        //cout is the number of Vertex in MST.
        int cout = 0;
        
        //traverse over the Min_Heap that contain all of the Vertex in Graph .
        while (!mh.isEmpty()) {
            
            //throw the Adjacent vertex.
            for (int i = 0; i < minkeyVertex.getAdjacentVertices().size(); i++) {
                
                //if the Adjacent vertex of the parent is not visitied.
                if (!minkeyVertex.getAdjacentVertices().get(i).getDestination().isVisited()) {
                    
                    // a is the index of the unvisited Adjacent vertex which represent the Destination .
                    int a = mh.vertexIndex(minkeyVertex.getAdjacentVertices().get(i).getDestination());
                    
                    //check if the key Vlaue of the unvisited Adjacent vertex is greater then its wight.
                    if (mh.H[a].key > minkeyVertex.getAdjacentVertices().get(i).getWeight()) {
                        
                        //Update the key Vlaue of the unvisited Adjacent vertex to its wight.
                        mh.UpdateKey(minkeyVertex.getAdjacentVertices().get(i).getWeight(), a);
                        
                        // a is the index of the unvisited Adjacent vertex which represent the Parent .
                        a = mh.vertexIndex(minkeyVertex.getAdjacentVertices().get(i).getDestination());
                        
                        //Update the parent of the Vertex
                        mh.H[a].setParent(minkeyVertex);
                    }

                }

            }
            //poll the Parent. 
            mn = mh.extract_min();
            
            //The parent Vertex.
            Vertex D = mn.getVertex();
            
            //Object line .
            Line line = new Line(mn.getParent(), mn.getVertex(), mn.getKey());
            
            //add the object to the MST.
            MSTResultList.set(cout, line);
            
            //increment cout.
            cout++;
            
            //set the vertex to visited.
            mn.vertex.setVisited(true);
            minkeyVertex = D;
        }
    }

    @Override
    public void displayResultingMST() {
        // Print the contents of result[] to display the
        //  MST
        System.out.println(
                "\nThe phone network (minimum spanning tree) generated by MinHeap Prim's algorithm is as follows: ");
        int minCost = 0;
        for (int i = 0; i < MSTResultList.size(); i++) {
            MSTResultList.get(i).displayInfo();
            minCost += MSTResultList.get(i).getWeight();
        }
        System.out.println("The cost of designed phone network: " + minCost + "\n");
    }
}
